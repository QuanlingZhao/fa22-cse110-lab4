1. Line 12 will display number of discounted item 3. (Length of prices)
2. Line 13 will display unrounded discounted price for last item in the list (150), it is a var so it can be accessed outside loop.
3. Line 14 will display rounded discounted price for last item in the list (150). (2 dicimal place)
4. The function will return a list of discounted prices of the input list. ([50,100,150])
5. Line 12 will cause an error since i in var and is in the scope of loop.
6. Line 13 will cause an error as discountedPrice is not accessible outside loop.
7. Line 14 will display 150, discounted price of last item in the list.
8. The function will return a list of discounted prices of the input list. ([50,100,150])
9. Line 11 will casue an error, because i is var and in the scope of loop.
10. Will display length of the list 3. Line 12 is in the same scope of length decleartion.
11. The function will return a list of discounted prices of the input list. ([50,100,150]). Although discounted is a const, it is a const list and its content and be expanded (similar to const pointer).
12. See Below
    - (A) student.name
    - (B) student['Grad Year']
    - (C) student.greeting()
    - (D) student['Favorite Teacher'].name
    - (E) student.courseLoad[0]
13. See below
    - (A) '32' - integer 2 map to string '2'
    - (B) 1 - string '3' map to integer 3
    - (C) 3 - null map to integer 0
    - (D) '3null' - null map to string 'null'
    - (E) 4 - true maps to integer 1
    - (F) 0 - both false and null maps to 0
    - (G) '3undefined' + undefined maps to undefined
    - (H) NaN - not supported conversion and operaation.
14. See below
    - (A) True - '2' maps to integer 2 which is larger than 1
    - (B) False - because first '2' comes after '1'
    - (C) True - Because '2' maps to integer 2
    - (D) False - they are of different type
    - (E) False - True maps to 1 which maps to not equal to 2
    - (F) True - Boolean(2) evaluates to bool True which is strictly equal to true.
15. == uses auto conversion and then compare, but === also consider type and always consider obj of different type different.
16. See part2-question16.js
17. Call returns [2,4,6], basicly, the modifyArray function takes in an array and a function, the function is then applied to every element of the arry, in this case is multiply by 2.
18. See part2-question18.js
19. Output is 1 4 3 2 sequentially.






















